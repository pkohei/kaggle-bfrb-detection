# CLAUDE.md

このファイルは、Claude Code (claude.ai/code) がこのリポジトリで作業する際のガイダンスを提供します。

## プロジェクト概要

これは **Kaggle競技プロジェクト** で、GitHub IssueとPull Requestを活用した構造化実験ワークフローによるBFRB（Body-Focused Repetitive Behaviors）検出を行います：
- **uv**: 高速な依存関係解決と管理のためのモダンなPythonパッケージマネージャー
- **Docker**: コンテナ化された開発環境
- **Dev Containers**: シームレスなコンテナベース開発のためのVS Code統合
- **CUDA対応**: 機械学習ワークロードのためのGPUコンピューティングサポート

### プロジェクトの説明

**Kaggle競技**: センサーデータを使用したBody-focused repetitive behaviors検出
- **目標**: 行動パターンの多クラス分類
- **データ**: 4つの行動クラスを持つ時系列センサーデータ
- **評価**: テストセットでの分類精度
- **ワークフロー**: PRベースの結果レビューを伴うIssue駆動実験開発

## 開発環境

このプロジェクトは、マシン間での一貫した開発環境のためにDevContainerを使用します。

### クイックスタート

1. VS Codeでプロジェクトを開く
2. コマンドパレットから「Dev Containers: Reopen in Container」を実行
3. 依存関係をインストール: `uv sync`
4. Kaggle認証情報を設定してデータをダウンロード: `uv run python scripts/setup_kaggle.py`
5. ベースラインモデルを作成: `uv run python scripts/create_quick_baseline.py`

## Kaggle競技コマンド

### セットアップとデータ管理

```bash
# Kaggle環境のセットアップと競技データのダウンロード
uv run python scripts/setup_kaggle.py

# プロジェクトの状況とデータサマリーの確認
uv run python scripts/project_summary.py
```

### モデル開発

```bash
# クイックベースラインモデルの作成（高速イテレーション推奨）
uv run python scripts/create_quick_baseline.py

# 複数アルゴリズムによる包括的ベースラインの作成
uv run python scripts/create_baseline.py
```

### パッケージ管理

```bash
# 依存関係のインストール（devグループも自動的に含まれる）
uv sync

# 新しいパッケージの追加
uv add package-name

# 開発パッケージの追加（dependency-groups使用）
uv add --group dev package-name

# 依存関係の更新
uv lock --upgrade
```

依存関係をインストールする際は、pyproject.tomlを直接編集するのではなく、`uv add`を使用してください。pyproject.tomlは自動的に更新されます。

### テスト

```bash
# 全テストの実行
uv run pytest

# カバレッジレポート付きでの実行
uv run pytest --cov

# 特定のテストファイルの実行
uv run pytest tests/test_main.py
```

### コード品質

```bash
# コードのフォーマット
uv run ruff format

# リンティングの実行
uv run ruff check

# リンティングエラーの自動修正
uv run ruff check --fix

# インポート順序の自動整理
uv run ruff check --select I --fix
```

### 型チェック

```bash
# 型チェックの実行
uv run mypy src
```

### pre-commitフック

```bash
# pre-commitフックのインストール
uv run pre-commit install

# 全ファイルでのフック実行
uv run pre-commit run --all-files
```

## プロジェクトアーキテクチャ

### ディレクトリ構造

- **ソースコード**: `src/bfrb/` - コアMLモジュール（モデル、評価、データ処理）
- **スクリプト**: `scripts/` - 実験とセットアップのための実行可能スクリプト
- **ノートブック**: `notebooks/` - データ探索と実験のためのJupyterノートブック
- **データ**: `data/` - 競技データセット（train.csv、test.csvなど）
- **提出**: `submissions/` - Kaggle用に生成された提出ファイル
- **結果**: `results/` - モデル評価結果とプロット
- **テスト**: `tests/` - pytestを使用したテストファイル
- **設定**: `pyproject.toml` - プロジェクト設定と依存関係
- **依存関係**: `uv.lock` - 再現可能なビルドのための依存関係ロックファイル
- **GitHubテンプレート**: `.github/` - 構造化ワークフローのためのIssueとPRテンプレート

### 主要技術

- **Python 3.12**: プログラミング言語
- **uv**: 高速Pythonパッケージマネージャー
- **scikit-learn, LightGBM, XGBoost**: 機械学習アルゴリズム
- **pandas, numpy**: データ操作と数値計算
- **matplotlib, seaborn, plotly**: データ可視化
- **pytest**: テストフレームワーク
- **ruff**: コードフォーマッターとリンター
- **mypy**: 静的型チェッカー
- **pre-commit**: コード品質のためのGitフック
- **Jupyter**: インタラクティブデータ分析
- **Kaggle API**: 競技データと提出管理

## 実験ワークフロー

### Issue駆動実験管理

**ユーザーから特に指定がない限り、実験開発では以下のワークフローに従ってください**

1. **実験計画（GitHub Issue）**
   - 実験テンプレートを使用してGitHub Issueを作成: `.github/ISSUE_TEMPLATE/experiment.md`
   - 仮説、手法、成功基準、予想スケジュールを定義
   - ベースライン比較と評価指標を含める
   - 実験アプローチについて承認/議論を得る

2. **実験セットアップ**
   - mainブランチをチェックアウトして最新の変更を取得: `git pull origin main`
   - 実験ブランチを作成: `git checkout -b experiment/[issue番号]-[簡潔な説明]`
   - 追跡可能性のためブランチ名にissue番号を含める

3. **実験開発**
   - Issueの計画に従って実験を実装
   - 再現性のため`scripts/`でスクリプトを作成または修正
   - 明確な結果とともにJupyterノートブックで実験を文書化
   - issueを参照する意味のあるメッセージでコミット

4. **実験実行と文書化**
   - 実験を実行して結果を収集
   - 可視化と性能指標を生成
   - 発見、洞察、次のステップを文書化
   - 該当する場合は提出ファイルを作成

5. **結果を含むPull Request**
   - 実験結果テンプレートを使用してPRを作成: `.github/PULL_REQUEST_TEMPLATE/experiment_results.md`
   - 実験結果、可視化、分析を含める
   - 主要な発見と推奨事項をまとめる
   - 文脈のため元のIssueにリンク

6. **レビューと統合**
   - レビューフィードバックと質問に対応
   - レビュワーと結果と影響について議論
   - 承認後にPRをマージし、関連Issueをクローズ
   - mainブランチを更新し、実験ブランチをクリーンアップ

### テンプレート

- **実験Issueテンプレート**: `.github/ISSUE_TEMPLATE/experiment.md`
- **実験PRテンプレート**: `.github/PULL_REQUEST_TEMPLATE/experiment_results.md`

### 言語規約

**IssueとPRは日本語で記述してください**
- タイトル、説明、コメントすべて日本語で記述
- コード内のコメントとdocstringも日本語推奨
- 変数名や関数名は英語のまま（Python慣例に従う）

## コード品質ガイドライン

### 実験コード基準

**本格コード** (src/bfrb/)：
- 完全な型ヒントと文書化
- 包括的なユニットテスト
- 100% ruff/mypy準拠
- 徹底したエラーハンドリング

**実験コード** (scripts/, notebooks/)：
- 主要関数の基本的な型ヒント
- メインワークフローの機能テスト
- ruffフォーマット必須、mypyの警告は許容
- 明確なコメントと文書化

**共通基準**:
- コードフォーマットには`ruff format`を使用
- ruffリンティングルールに従う（`ruff check`）
- コミット前に`mypy`を実行（実験では警告OK）
- Python命名規則に従う（PEP 8）
- パブリック関数とクラスにdocstringを記述

### 実験ベストプラクティス

- **再現性**: ランダムシードを設定し、すべてのパラメータを文書化
- **バージョン管理**: 明確で説明的なメッセージで実験コードをコミット
- **文書化**: 探索的分析と結果にJupyterノートブックを使用
- **性能追跡**: 検証スコアを監視し、実験履歴を追跡
- **リソース管理**: 計算要件と実行時間を文書化

### テスト要件

**本格コード**:
- 包括的なユニットテストを記述
- テストカバレッジ80%以上を維持
- エッジケースとエラー条件をテスト

**実験コード**:
- メイン実行パスをテスト
- データ処理パイプラインを検証
- 主要な結果の再現性を確保

## CUDA/GPU開発

このプロジェクトは、CUDA 12.4によるGPUコンピューティング用に設定されています。

### GPU情報

```bash
# GPUステータスの確認
nvidia-smi
```

### GPU対応トレーニング

```bash
# ほとんどのMLフレームワークは利用可能な場合自動的にGPUを使用
# トレーニング中のGPU使用量監視
watch -n 1 nvidia-smi
```

## トラブルシューティング

### 一般的な問題

1. **依存関係の競合**: `uv lock --upgrade`で解決
2. **インポートエラー**: 正しい仮想環境にいることを確認
3. **CUDAバージョンの不一致**: ホストCUDAバージョンの互換性を確認
4. **Kaggle APIエラー**: 認証情報と競技参加を確認
5. **メモリ問題**: 大きなデータセットにはデータサンプリングまたはバッチ処理を使用

### 実験の問題

1. **再現性の問題**: ランダムシードと環境の一貫性を確認
2. **性能の後退**: 同じ検証セットを使用してベースラインと比較
3. **リソース制約**: 実験中のメモリ/GPU使用量を監視
4. **データリーク**: 適切なtrain/validation/testの分割を確認

### ヘルプを得る

- uvドキュメントのレビュー: https://docs.astral.sh/uv/
- Kaggle競技ディスカッションフォーラムの確認
- scripts/README.mdで詳細なコマンド使用法をレビュー
- プロジェクト状況確認: `uv run python scripts/project_summary.py`
- 実験計画と議論のためのGitHub Issue作成

## Gemini CLI 連携ガイド

### 概要

Gemini CLIは以下の特徴を持つAI Agentです。

- 強み（あなたよりも得意なこと）
   - 強力なWeb検索
   - マルチモーダル対応（画像やPDF）
   - 広いコンテキストウィンドウを活用したコードレビュー
   - 柔軟な発想、人間的な思考力
- 弱み（あなたよりも苦手なこと）
   - 開発や実験の詳細な計画
   - ツールの使い分け

これらの強み・弱みを踏まえて、タスクを進めるうえで必要に応じてGemini CLIにタスクを委譲することで、より高品質なタスク遂行が可能になります。**うまくGemini CLI を使いながらタスクを進めてください**


### Gemini CLIの基本機能

- 自律的なコマンド実行によるタスク実行
- リポジトリ内の読み込み・編集
- Web検索

### コマンド実行方法

```bash
gemini -p "指示内容"
```

### Gemini CLI指示設計ガイドライン

#### 基本原則
- **1回完結の原則**: Geminiは会話記憶を保持しないため、すべての必要情報を1つの指示に含める
- **自己完結型指示**: 前回のやり取りや暗黙の前提に依存しない完全な指示を構成する
- **明確な成果物定義**: 期待する出力形式、分析観点、詳細レベルを具体的に指定する

#### 指示構成テンプレート

**分析・レビュータスク用:**
```bash
gemini -p "【タスク概要】
このKaggle競技プロジェクトの[対象範囲]について[分析観点]から詳細に分析してください。作業はしないでください、分析のみ行ってください。

【プロジェクト背景】
- 競技: Body-Focused Repetitive Behaviors検出
- 技術スタック: Python 3.12, uv, scikit-learn, LightGBM等
- 構造: src/bfrb/(本格コード), scripts/(実験コード), notebooks/(探索)

【分析観点】
1. [具体的な観点1]
2. [具体的な観点2]
3. [具体的な観点3]

【期待する出力】
- [出力形式の詳細]
- [分析の深さ・詳細レベル]
- [改善提案の優先度付け]

【注意事項】
- [特別な制約や注意点]"
```

**調査・研究タスク用:**
```bash
gemini -p "【調査目的】
[具体的な調査目的と背景]

【調査対象】
- [調査範囲の明確化]
- [重点的に調べるべき項目]

【調査方法】
- Web検索を活用して最新情報を収集
- [その他の調査手法]

【成果物】
- [調査結果の整理方法]
- [参考文献やソースの記載方法]

作業はしないでください、調査・分析のみ行ってください。"
```

#### 効果的な指示のチェックリスト
- [ ] プロジェクトの背景・文脈を含んでいる
- [ ] 具体的な分析観点・調査項目を列挙している
- [ ] 期待する出力形式を明確に定義している
- [ ] 「作業はしないでください」など制約を明記している
- [ ] 優先度付けや詳細レベルを指定している
- [ ] 前回のやり取りに依存していない自己完結型になっている

### 注意点

- Gemini CLIは特に指定しないとファイル編集作業などを積極的に実行してしまうため、Geminiに不可逆な作業をさせたくない場合は指示内容に明確に「作業はしないでください」という内容を付け加える必要があります。
- Gemini CLIは会話に関する記憶を保持せず、コマンド実行ごとにすべてを忘れます。そのため重要な会話履歴は指示内容に加える必要があります。
- Gemini CLIは安全と判断したコマンドしか内部で自律的に実行しません。Gemini CLIが不完全な仕事しかしなかった場合は、必要に応じて `gemini --yolo -p "指示内容"` を実行することで全てのコマンド実行を許可することができます。

### ツール選択ガイドライン

#### タスク分類とツール選択マトリックス

| タスクの種類 | 推奨ツール | 理由 | 例 |
|-------------|-----------|------|-----|
| **包括的コードレビュー** | Gemini CLI | 広いコンテキスト、俯瞰的分析 | プロジェクト全体の設計分析 |
| **技術調査・最新情報収集** | Gemini CLI | 強力なWeb検索、多角的分析 | 新しいライブラリの調査、技術比較 |
| **複雑な分析・判断** | Gemini CLI | 柔軟な発想、人間的思考力 | 実験結果の解釈、改善提案 |
| **特定ファイルの検索** | Task/Grep/Glob | 高速、正確な検索 | 関数定義の場所特定 |
| **Web情報の要約** | WebFetch | 単一URL、構造化された要約 | 特定ドキュメントの内容確認 |

#### 判断フローチャート

**1. 分析・レビュータスクの場合**
- 複数ファイル・全体的な分析が必要 → **Gemini CLI**
- 特定ファイル・限定的な分析 → **Read + 直接分析**

**2. 情報収集タスクの場合**
- 調査・検索が必要 → **Gemini CLI (Web検索活用)**
- 特定URLの内容確認のみ → **WebFetch**

**3. コード検索タスクの場合**
- キーワード・パターン検索 → **Task/Grep**
- ファイル名・パス検索 → **Glob**
- 複雑な条件・複数の検索ラウンド → **Task**

#### Gemini CLI最適活用シーン

**積極的に使うべき場面:**
- プロジェクト全体のアーキテクチャ分析
- 技術調査・最新情報収集（Web検索活用）
- 複数技術の比較検討
- 実験結果の解釈と改善提案
- コード品質の包括的評価
- 技術動向の調査

**避けるべき場面:**
- 単純なファイル検索・読み取り
- 定型的なコード生成
- 単一の関数・クラスの修正
- 既知の手順・コマンドの実行

### Gemini CLI連携ワークフロー

#### 基本的な連携パターン

**パターン1: 分析→改善実装**
1. **Gemini分析** - コードベース全体の品質分析を実行
2. **結果整理** - 優先度付きの改善提案リストを作成
3. **TodoWrite活用** - 改善項目をタスクリストに追加
4. **段階的実装** - 高優先度から順次実装
5. **継続監視** - 定期的な再分析で改善効果を確認

**パターン2: 調査→実験計画**
1. **Gemini調査** - 技術動向や新手法の調査
2. **実験計画** - GitHub Issueで実験提案を作成
3. **実装** - 調査結果を基にした実験コード開発
4. **検証** - Geminiによる実験結果の解釈と評価
5. **フィードバック** - 次の実験への改善提案

**パターン3: レビュー→リファクタリング**
1. **Gemini レビュー** - 特定モジュールの詳細分析
2. **問題特定** - 技術的負債や改善点の洗い出し
3. **リファクタリング計画** - 具体的な改修手順の策定
4. **実装** - 段階的なコード改善
5. **品質確認** - テスト実行とGeminiによる再レビュー

#### 実験プロジェクト特化ワークフロー

**Phase 1: 実験前準備**
```bash
# 1. 技術調査
gemini -p "【調査目的】[新しい手法・ライブラリ]について調査
【期待する成果】実験での活用可能性、メリット・デメリット、実装方法"

# 2. ベースライン分析
gemini -p "【分析対象】現在の実験結果とモデル性能
【期待する成果】改善の方向性、次の実験アイデア"
```

**Phase 2: 実験実行中**
```bash
# 3. 実験結果の中間評価
gemini -p "【評価対象】実験の中間結果とログ
【期待する成果】実験継続の判断、パラメータ調整提案"
```

**Phase 3: 実験後分析**
```bash
# 4. 総合評価と次のステップ
gemini -p "【分析対象】実験の最終結果、可視化、比較分析
【期待する成果】成果のまとめ、次の実験提案、PR用の説明"
```

#### 成果物の活用方法

**Gemini分析結果の構造化:**
- **immediate**: 即座に実装すべき項目
- **planned**: 次の開発サイクルで実装予定
- **research**: さらなる調査が必要な項目
- **future**: 将来的な改善アイデア

**GitHub統合:**
- 分析結果から自動的にIssue作成のテンプレート生成
- PR説明文への分析サマリー統合
- 実験レポートへの洞察の組み込み

#### 実験サイクル統合

**実験ライフサイクルでのGemini活用:**
- **実験開始前**: Geminiによる手法調査と計画レビュー
- **実験中**: 中間結果のGemini分析
- **実験終了後**: 包括的な結果評価と次のステップ提案

#### トラブルシューティング

**Gemini分析が期待と異なる場合:**
1. 指示内容の見直し（テンプレート活用）
2. より具体的な分析観点の追加
3. プロジェクト背景情報の補強

**分析結果の活用が困難な場合:**
1. 優先度による段階的実装
2. 小さな改善から開始
3. 定期的な効果測定

### ドキュメント

Gemini CLIの使い方について悩んだときは下記のドキュメントを参照してください。

- https://github.com/google-gemini/gemini-cli/blob/main/docs/index.md
